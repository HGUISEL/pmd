/**
 * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
 */
/* Generated By:JJTree: Do not edit this line. ASTNullLiteral.java */

package net.sourceforge.pmd.lang.java.ast;

import java.util.function.BiFunction;
import java.util.function.Function;


/**
 * An ambiguous name occurring in any context. Without a disambiguation pass that
 * taking care of obscuring rules and the current declarations in scope, this node could be
 * a type, package, or variable name -we can't know for sure. The node is a placeholder
 * for that unknown entity. It implements both {@link ASTType} and {@link ASTPrimaryExpression}
 * to be able to be inserted in their hierarchy. E.g. if the LHS of a method call is an ambiguous
 * name,
 *
 * <p>This node corresponds simultaneously to the <a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-6.html#jls-AmbiguousName">AmbiguousName</a>
 * and PackageOrTypeName productions of the JLS.
 *
 * <pre>
 *
 * AmbiguousNameExpr ::= &lt;IDENTIFIER&gt; ( "." &lt;IDENTIFIER&gt;)*
 *
 * </pre>
 */
public final class ASTAmbiguousName extends AbstractJavaTypeNode implements ASTReferenceType, ASTPrimaryExpression {

    ASTAmbiguousName(int id) {
        super(id);
    }


    ASTAmbiguousName(String id) {
        super(JavaParserTreeConstants.JJTAMBIGUOUSNAME);
        setImage(id);
    }


    ASTAmbiguousName(JavaParser p, int id) {
        super(p, id);
    }


    public String getName() {
        return getImage();
    }


    @Override
    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }


    @Override
    public <T> void jjtAccept(SideEffectingVisitor<T> visitor, T data) {
        visitor.visit(this, data);
    }


    /**
     * Called by the parser if this ambiguous name was a full expression.
     * Then, since the node was in an expression syntactic context,
     * we can do some preliminary reclassification:
     * * If the name is a single identifier, then this can be
     * reclassified as an {@link ASTVariableReference}
     * * If the name is a sequence of identifiers, then the last
     * segment can be reclassified as an {@link ASTFieldAccess},
     * and the rest of the sequence (to the left) is left ambiguous.
     *
     * @return the node which will replace this node in the tree
     */
    ASTExpression disambiguateInExprContext() {
        // by the time this is called, this node is on top of the stack,
        // meaning, it has no parent
        return shrinkOneSegment(ASTVariableReference::new, ASTFieldAccess::new);
    }


    /**
     * Called by the parser if this ambiguous name occurred in a type name context.
     *
     * From JLS:
     *
     * A name is syntactically classified as a TypeName in these contexts:
     *
     * The first eleven non-generic contexts (§6.1):
     *
     * In a uses or provides directive in a module declaration (§7.7.1)
     *
     * In a single-type-import declaration (§7.5.1)
     *
     * To the left of the . in a single-static-import declaration (§7.5.3)
     *
     * To the left of the . in a static-import-on-demand declaration (§7.5.4)
     *
     * To the left of the ( in a constructor declaration (§8.8)
     *
     * After the @ sign in an annotation (§9.7)
     *
     * To the left of .class in a class literal (§15.8.2)
     *
     * To the left of .this in a qualified this expression (§15.8.4)
     *
     * To the left of .super in a qualified superclass field access expression (§15.11.2)
     *
     * To the left of .Identifier or .super.Identifier in a qualified method invocation expression (§15.12)
     *
     * To the left of .super:: in a method reference expression (§15.13)
     */
    //    ASTClassOrInterfaceType disambiguateInTypeContext() {
    //
    //    }

    <T> T shrinkOneSegment(Function<ASTAmbiguousName, T> simpleNameHandler,
                           BiFunction<ASTAmbiguousName, String, T> splitConsumer) {

        String image = getImage();

        int lastDotIdx = image.lastIndexOf('.');

        if (lastDotIdx < 0) {
            return simpleNameHandler.apply(this);
        }

        String lastSegment = image.substring(lastDotIdx + 1);
        String remainingAmbiguous = image.substring(0, lastDotIdx);

        // execute the handler before shrinking the text bounds,
        // to allow the new node to copy the full text coordinates
        T res = splitConsumer.apply(this, lastSegment);

        shiftColumns(0, -lastSegment.length() - 1);
        setImage(remainingAmbiguous);
        return res;
    }


    @Override
    public String getTypeImage() {
        return getImage();
    }
}
